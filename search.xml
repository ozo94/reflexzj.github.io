<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[c++算法整理]]></title>
      <url>%2F2017%2F03%2F29%2Fc_c%2B%2B_%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[持续整理，从简单的算法开始。与原来记忆中的知识体系形成一个对照，帮助复习和记忆。 字符串 字符串逆置统计字符串的长度length()? size()(其实这两个的功能是一样的，c++更倾向于用size(),用于STL中)除了考虑时间复杂度，空间复杂度的问题需不需要考虑？（这可是c++啊，新建一个字符串，逆序存入的方法，真是给大学算法老师丢脸了。）不出所料地，出现了 Runtime Error 的错误。 1234567891011class Solution &#123;public: string reverseString(string s) &#123; int len=s.size(); string result; for(int i=len-1; i&gt;=0; i--)&#123; result[len-i-1]=s[i]; &#125; return result; &#125;&#125;; 给出最优的方案1234567891011class Solution &#123;public: string reverseString(string s) &#123; int i = 0, j = s.size() - 1; while(i &lt; j)&#123; swap(s[i++], s[j--]); &#125; return s; &#125;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python算法练习]]></title>
      <url>%2F2017%2F03%2F29%2Fpython%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[从基础算法开始，一道道的刷过去，争取早日熟悉python的语法。持续更新…… 字符串 字符串逆序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[post&get 方法]]></title>
      <url>%2F2017%2F03%2F15%2Fpost_get%2F</url>
      <content type="text"><![CDATA[HTTP 定义了与服务器交互的不同方法，最基本的方法是 GET 和 POST（Ajax开发，关心的只有GET请求和POST请求）。 GET与POST方法有以下区别： 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。 GET方式提交的数据最多只能有1024字节，而POST则没有此限制。 安全性问题。使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python异常处理方法]]></title>
      <url>%2F2017%2F03%2F11%2Ftry%E8%AF%AD%E5%8F%A5%2F</url>
      <content type="text"><![CDATA[1.捕获所有异常123456try: a=b b=c except Exception,e: print Exception,&quot;:&quot;,e 2.采用traceback模块查看异常1234567891011121314151617181920#引入python中的traceback模块，跟踪错误import traceback try: a=b b=c except: traceback.print_exc()#也可以将异常存储到日志文件中去import tracebacktry: a=b b=c except: f=open("c:log.txt",'a') traceback.print_exc(file=f) f.flush() f.close() 3.采用sys模块回溯最后的异常12345678#引入sys模块import sys try: a=b b=c except: info=sys.exc_info() print info[0],":",info[1]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[openedx的基本配置]]></title>
      <url>%2F2017%2F03%2F08%2Fopenedx%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[搭建好openedx后，我们需要对edx的一些基本功能进行配置edx文档参考手册官方网站（包括API调用、开发者手册）：http://docs.edx.org/openedx的配置主要参考安装配置手册：http://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/index.html原博客参考：https://shanbin.name/openedx-concise-configuration-guide/ 配置SMTP主要涉及/edx/app/edxapp/下的4个json文件 lms.env.json 1234567891011121314151617#设置成你的smtp邮箱“DEFAULT_FROM_EMAIL”: “your email”, #内容修改成你的smtp主机，比如你的邮箱设置的QQ邮箱则是smtp.qq.com“EMAIL_HOST”: “smtp.qq.com”, #端口一般是25 “EMAIL_PORT”: 25, #你的平台域名，可填ip“LMS_BASE”: “example.com”, #内容修改成你的edX平台名字“PLATFORM_NAME”: “OPENEDX”, #域名或ip,激活邮箱时调用 “SITE_NAME”: “localhost”, cms.env.json 12345678910#设置成你的smtp邮箱“BULK_EMAIL_DEFAULT_FROM_EMAIL”: “your email”, #设置成你的smtp邮箱“DEFAULT_FROM_EMAIL”: “your email”, “EMAIL_HOST”: “smtp.qq.com”, “EMAIL_PORT”: 25, “LMS_BASE”: “example.com”, “SITE_NAME”: “localhost”, lms.auth.json 12345#smtp邮箱密码“EMAIL_HOST_PASSWORD”: “password”, #邮箱“EMAIL_HOST_USER”: “email”, cms.authe.json 12345#smtp邮箱密码“EMAIL_HOST_PASSWORD”: “password”, #邮箱 “EMAIL_HOST_USER”: “email”, 管理命令 添加管理员用户找到 .manage.py 所在的目录文件执行命令 1sudo -u www-data /edx/bin/python.edxapp ./manage.py lms --settings=aws createsuperuser 列出所有的manage.py参数命令 12sudo -u www-data /edx/app/edxapp/venvs/edxapp/bin/python/edx/app/edxapp/edx-platform/manage.py lms –-settings=aws helpn 重启edxapp 1sudo /edx/bin/supervisorctl restart edxapp: 查看服务器状态 1sudo /edx/bin/supervisorctl status 文件编译在edxapp账户下对lms模块进行编译，编译结束后要重启edxapp(cms编译时进行对应修改即可) 切换edxapp账户 1sudo -H -u edxapp bash 编译静态文件 123source /edx/app/edxapp/edxapp_envcd /edx/app/edxapp/edx-platformpaver update_assets lms --settings=aws 重启edxapp 1sudo /edx/bin/supervisorctl restart edxapp:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[openedx搭建笔记]]></title>
      <url>%2F2017%2F03%2F01%2Fopenedx%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[小组实训任务：在开源项目openedx的基础上，搭建自己的MOOC平台 openedx这个项目已经进行很久了，github上有持续更新，目前，平台上的各种功能已经比较完善了。 git安装的方法由于外网的原因，openedx的直接安装一般不太可能成功，优先选择手动安装的方法。 根据你的ubuntu系统来选择安装（目前支持ubuntu12.04LTS, ubuntu16.04LTS两个版本，配置要求不同（内存，最低硬盘容量要求）），可以参考gihub上的 edx/configuration 、edx/edx-platform 这两个开源项目 本人使用了12.04的安装平台，具体的安装方法可以参考：https://openedx.atlassian.net/wiki/display/OpenOPS/Native+Open+edX+Ubuntu+12.04+64+bit+Installation 这里罗列了一些手动安装过程中会出现的一些问题 由于接触ubuntu不多，需要明白一个原则：每一步的命令执行没有问题之后，才能接着执行下面的命令 安装过程中的问题，主要集中在检查配置文件，向git请求下载的过程之中1sudo ansible-playbook -c local ./edx_sandbox.yml -i &quot;localhost,&quot; 整理了一些错误报告（1） cannot import name _unicode py对应的mongo数据库没有安装成功（python链接mongo数据库的中间键） sudo apt-get install python-pymongo 已经安装了还是不行，选择安装最新版本的 sudo pip uninstall pymongo bson sudo pip install pymongo --upgrade （2）pip软件包的警告 SNIMissingWarning: An HTTPS request has been made,….see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning. 解决方案pip install pyopenssl ndg-httpsclient pyasn1 （3）用户权限问题 The directory ‘/home/onemind/.cache/pip/http’ or its parent directory is not owned by the current user and the cache has been disabled. 可以参考linux权限辅助的处理方案 （4）安装mongo服务器时候 “msg”: “Failed to update apt cache.” 删除 /var/lib/apt/lists下所有缓存文件sudo rm -rf * 更新apt列表sudo apt-get update ova镜像挂载挂载打包好的opeedx OVA镜像，可以免除繁琐的下载过程，但需要后期的配置主要是配置网络IPedustack网站给出的指引方案可以参考：http://edustack.org/manual/edx/open-edx-ebook%E4%B8%AD%E6%96%87%E7%89%88/ run文件安装bitnami开源项目托管网站打包了openedx的开源项目。当然，打包的项目不可能是最新的开发版了。附上地址：https://bitnami.com/stack/edx该文件是在ubuntu系统下进行安装： 安装openedx添加权限后安装 12sudo chmod 755 bitnami-edx-20160414-4-linux-x64-installer.run./bitnami-edx-20160414-4-linux-x64-installer.run 安装配置安装过程中，需要配置ip，托管邮箱等（用以发送邮件验证）如果在图形界面中配置，则很简单附上dos界面的配置 修改主机名/ip地址 1sudo installdir/apps/edx/bnconfig --machine_hostname NEW_DOMAIN(服务器ip) 备份 12$ /home/azureuser/edx-20160414-4/ctlscript.sh stop$ tar -pczvf application-backup.tar.gz /home/azureuser/edx-20160414-4 启动openedx 1$ /home/azureuser/edx-20160414-4/ctlscript.sh start box文件github上放出的最新的box镜像环境要求：vagrant+vitualbox参考地址：http://edx.readthedocs.io/projects/edx-installing-configuring-and-running/en/latest/installation/index.html安装vagrant(ubuntu/windows平台都有)，安装完成后自动，重启会自动完成所有的路径配置操作流程 新建一个文件夹 导入对应的box文件 12vagrant box add (name) (file_directory)vagrant init (name) 修改配置文件 打开网络地址（包括本地网络和外网地址） 12config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot; 配置映射文件本地文件夹–&gt;映射文件夹（虚拟机中产生对应的文件夹）以当前文件目录为起始点 1config.vm.synced_folder &quot;./data&quot;, &quot;/vagrant_data&quot; 启动、结束、重启 123vagrant upvagrant haltvagrant reload]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python进制转换]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
      <content type="text"><![CDATA[123二进制： bin(num)八进制： oct(num)十六进制： hex(num) 汉明距离汉明距离：两个数进行二进制转换后，不同的位数 思路：两个数之间进行异或操作，不同的位置将会标’1’ 分别给出python和c++的代码实现1bin(x^y).count('1') c++中通过按位与的方法来做，很巧妙123456n=x^ywhile(n)&#123; ++flag; n &amp;= n - 1;&#125; 实现按位的非操作（在python中并没有’!a’这样的表达形式）思路：要想’0’，’1’发生互换，对应位置与’1’进行异或操作难点在于：产生与num二进制转化后，同样长度的’1’125(101) (111) 给出巧妙的代码1234567def findComplement(self, num): i = 1 while i &lt;= num: i = i &lt;&lt; 1 return (i - 1) ^ num#5 (0101)#i-1(0111)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[静态网页爬虫抓取]]></title>
      <url>%2F2016%2F12%2F05%2F%E9%9D%99%E6%80%81%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E6%8A%93%E5%8F%96%2F</url>
      <content type="text"><![CDATA[爬虫是一种自动抓取互联网信息的程序，可以取互联网中有价值的数据。传统的人工方式，通过URL之间的联系来获取网页，覆盖面小，效率低下。开发一个最简易的爬虫（爬去静态网页，没有使用框架，效率很低，仅作为对爬虫的入门了解）源码地址：https://github.com/reflexzj/simple-crawler.git 一、概述简单的爬虫组成 URL管理器 网页下载器 网页解析器这三个部分组成 给出三个部件协同工作流程 二、url管理器为什么需要urlManager这个组件？ 防止重复抓取、循环抓取（最坏情况：两个URL之间相互指向） 添加新的URL时需要判断 URL管理的基本功能范围 实现方案 使用集合将待爬取的url放入集合中python中的set()方法可以去除重复元素 关系型数据库通过表和相应的标志位来实现这个功能 缓存数据库eg:redis,使用两个数据的方案（大型公司的选用方式）个人可以使用电脑的内存或者是关系型数据库 三、网页下载器将互联网上URL对应的网页下载到本地的工具 工具 urllib2Python官方的基础模块： 支持直接的URL下载 向网页提交一些需要用户输入的数据 需要登陆网页的cookie处理 代理访问功能 requests第三方插件，提供更为强大的功能 urllib2用法 1.将URL传送给urllib2.urlopen()方法123456789import urllib2 #直接请求 response = urllib2.urlopen('http://www.baidu.com') #获取状态码，如果是200，则表示获取成功 print response.getcode() #读取内容 contt = response.read() 2.添加data、http header 增强处理：向服务器提交需要用户输入的数据 将url、data、header等信息传给request，将request对象作为参数发送网页请求123456789101112import urllib2 #创建request对象 request = urllib2.request(url) #添加数据（'a'这个数据项的值为'1'） request.add_data('a','1') #添加http的header（伪装成Mozilla浏览器） request.add_header('USer-Agent','Mozilla/5.0') #发送请求获取结果 response = urllib2.urlopen(request) 3.添加特殊场景的处理登陆访问：HTTPCookieProcesser 代理访问：ProxyHandler 协议加密：HTTPSHandler URL之间相互跳转：HTTPRedirectHandler …..eg：增强cookie的处理123456789101112import urllib2, cookielib #创建cookie容器 cj = cookielib.CookieJar() #将cookieJar作为一个参数生成对应的Handler，将此Handler传给Opener opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj)) #增强处理器，为urllib2安装opener urllib2.install_opener(opener) #此时使用带有cookie的urllib2来访问网页 response = urllib2.urlopen("http://www.baidu.com/") 四、网页解析器种类介绍 1.模糊匹配解析正则表达式 将整个网页文档当成一个字符串，使用模糊匹配的方式提取数据 直观，面对复杂内容，效率底下 2.结构化解析将整个网页文档下成一个文档对象模型树DOM(document Object Model) 解析工具： 1.html.parser自带的解析工具 2.Beautiful Soup可已使用html.parser以及Ixml来作为其的解析器 3.Ixml Beautiful Soup 安装文档参考地址：https://www.crummy.com/software/BeautifulSoup/bs4/doc/在windows环境下通过python工具包自带的pip工具来安装pip程序在Scripts文件中，检查是否安装 cd python_27\Scripts安装 pip install beautifulsoup4 用法 原理根据下载好的Html网页创建一个BeatifulSoup对象，文档则会变为相应的DOM树 代码实现（1）创建BeautifulSoup对象 1234 from bs4 import BeautifulSoup#根据HTML网页字符串创建BeautifulSoup对象#对象中的参数分别表示为HTML文档字符串、HTML解析器、指定文档的编码soup= BeautifulSoup(html_doc,'html.parser',from_encoding='utf8') （2）搜索节点（find_all,find） 这两个方法具有相同的参数：d_all(name,attrs,string) find_all() 搜索所有满足条件的节点 find() 搜索第一个满足条件的节点 -方法中的三个参数代表搜索的三个方向，分为名称、属性、内容 123456789#查找所有标签为a的节点soup.find_all('a')#查找所有标签为啊，链接符合/view/123.htm形式的节点(也可以传入正则表达式)soup.find_all('a',href='/view/123.htm')soup.find_all('a',href=re.compile(r'/view/\d+\.htm'))#查找所有标签为div，class为abc，文字为Python的节点(class为python关键字，加下划线避免冲突)soup.find_all('div',class_='abc',string='Python') （3）访问节点信息 12345678910 #得到节点：&lt;a href='1.html'&gt;Python&lt;/a&gt;#获取查找到的节点标签名称node.name#获取查找到的a节点的href属性node['href']#获取查找到的a节点的链接文字node.get_text()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[__name__ = '__main__' 的作用]]></title>
      <url>%2F2016%2F10%2F05%2Fmain%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[给一个模块12345#module.pydef main(): print "we are in %s"%__name__if __name__ == '__main__': main() 这个函数定义了一个main函数，执行后打印出”we are in main“,说明if语句中的内容被执行了，调用了main() 从另外一个模块中调用main()方法123#anothermodle.pyfrom module import mainmain() 执行的结果是：we are in module 没有显示”we are in main“,也就是说模块name = ‘main‘ 下面的函数没有执行。 分析直接执行某个.py文件的时候，该文件中那么”name == ‘main‘“是True,但是如果从另外一个.py文件通过import导入该文件的时候，这时name的值就是这个py文件的名字而不是main。 这个功能还有一个用处：调试代码的时候，在”if name == ‘main‘“中加入一些的调试代码，可以让外部模块调用的时候不执行调试代码，但是如果想排查问题的时候，直接执行该模块文件，调试代码能够正常运行。]]></content>
    </entry>

    
  
  
</search>
